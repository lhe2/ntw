---
title: "tdt stats"
date: "2025-06-16"
---

# # preamble & loading

```{r}
# libraries
library(tidyverse)
#library(MuMIn) # for survival nested model comparisons
library(survival) # for fitting 
library(survminer) # for plotting


# pathfinding
here::i_am("2025/tdt/analysis-stats.Rmd")
library(here)

source(here::here("set-paths.R"))
source(here(bin_paths$y25$tdt, "analysis-utils.R")) # helper functions
```

```{r}
# data import
source(here(bin_paths$y25$tdt, "wrangle_p.R"))

ogkm <- km #bc i am very indecisive w how im handling my data lol
```

## todos & notes

- 2025-07-16
  - [>] prob need to rerun A now that ive fixed the decimal hours calcs finally LO L L...
  - [ ] figure out when my bugs start to enter in the km viz lol üòµ‚Äçüí´ 
    - (idk if t0 = hatch or enter... also if the standardising is alrdy accounted for lol)
- 2025-08-13
  - ARCHIVE whatever is left of this sheet lol when done
    
    
notes

- 2025-07-17 re: jdate vs dh
  - cohort B: after updates to cleaning script, `dh` is calculated in days (should be hours, ideally)... jdate is calculated in days (so just be careful w axes)
  - this will probably break some of the cohort A analyses lol
  
## df prep
```{r some data prep}
# stole this from cohort B fups to use for cohort B and onwards analyses bc it works well

km <- list_assign(km, data =  ogkm$data %>%
                    mutate(across(starts_with(c("exit.", "dh.", "max", "day.")), ~ . * 24)))

## TODO:BUG some cohort C individs are breaking with negative exit times
km$data <- km$data %>%
  mutate(exit.fromenter = case_when(exit.fromenter < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromenter)),
         exit.fromrecover = case_when(exit.fromrecover < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromrecover)),
         exit.fromreturn = case_when(exit.fromreturn < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromreturn)))

km <- list_assign(km, subsets = list(ctrls = filter(km$data, trt.enter == trt.recover),
                                     expts = filter(km$data, trt.enter != trt.recover),
                                     only40 = filter(km$data, trt.enter == 40),
                                     recs = filter(km$data, trt > 40),
                                     rec24 = filter(km$data, trt == 40 | trt.duration == 24),
                                     rec48 = filter(km$data, trt == 40 | trt.duration == 48)))
```


=====

# # R3

includes cohort B + C

```{r}
for (l in c("survObjs", "fits")) {
  assign(l, list())
}
```

```{r}
dfs <- list_assign(dfs, 
                   all = km$data %>% filter(cohort != "A"),
                   hot = km$data %>% filter(is.40C == "Y"),
                   rec = km$data %>% filter(cohort != "A" & trt.duration > 0),
                   group = km$data %>% filter(cohort != "A" & trt.duration > 0) %>%
                     group_by(cohort, trt.recover, trt.duration) %>% 
                     summarise(day.enter, day.recover, day.return) %>%
                     drop_na() %>% unique()
                   )
```
```{r}
dfs <- list_assign(dfs, 
                   onlyC = km$data %>% filter(cohort == "C"),
                   recC = km$data %>% filter(cohort == "C" & trt.duration > 0))
```

## = 2025-08-11 pre mtg

### coxph trts (B+C)

```{r}
survObjs <- list_assign(survObjs, r1 = list())
fits <- list_assign(fits, r1 = list())
```

```{r}
# B + C
survObjs$r1 <- list_assign(survObjs$r1,
                            fromEnter = Surv(dfs$rec$exit.fromenter, dfs$rec$km.status),
                            fromRecovery = Surv(dfs$rec$exit.fromrecover, dfs$rec$km.status),
                            fromReturn = Surv(dfs$rec$exit.fromreturn, dfs$rec$km.status)
                            )

fits$r1 <- list_assign(fits$r1,
                    cph.enter = coxph(survObjs$r1$fromEnter ~ trt.recover * as.factor(trt.duration), 
                                      data = dfs$rec),
                    cph.recovery = coxph(survObjs$r1$fromRecovery ~ trt.recover * as.factor(trt.duration), 
                                         data = dfs$rec),
                    cph.return = coxph(survObjs$r1$fromReturn ~ trt.recover * as.factor(trt.duration),
                                       data = dfs$rec)
                    )

                                       
summary(fits$r1$cph.enter)
summary(fits$r1$cph.recovery)
summary(fits$r1$cph.return)
```
### coxph trts (C only)
```{r}
survObjs$r1 <- list_assign(survObjs$r1,
                            fromEnter = Surv(dfs$recC$exit.fromenter, dfs$recC$km.status),
                            fromRecovery = Surv(dfs$recC$exit.fromrecover, dfs$recC$km.status),
                            fromReturn = Surv(dfs$recC$exit.fromreturn, dfs$recC$km.status)
                            )

## duration as factor -- leads to NAs
fits$r1 <- list_assign(fits$r1,
                    cph.enter = coxph(survObjs$r1$fromEnter ~ trt.recover * as.factor(trt.duration), 
                                      data = dfs$recC),
                    cph.recovery = coxph(survObjs$r1$fromRecovery ~ trt.recover * as.factor(trt.duration), 
                                         data = dfs$recC),
                    cph.return = coxph(survObjs$r1$fromReturn ~ trt.recover * as.factor(trt.duration),
                                       data = dfs$recC)
                    )

                                       
summary(fits$r1$cph.enter)
summary(fits$r1$cph.recovery)
summary(fits$r1$cph.return)
```

```{r}
## fits as numeric
fits$r1 <- list_assign(fits$r1,
                    cph.enter = coxph(survObjs$r1$fromEnter ~ trt.recover * trt.duration, 
                                      data = dfs$recC),
                    cph.recovery = coxph(survObjs$r1$fromRecovery ~ trt.recover * trt.duration, 
                                         data = dfs$recC),
                    cph.return = coxph(survObjs$r1$fromReturn ~ trt.recover * trt.duration,
                                       data = dfs$recC)
                    )

                                       
summary(fits$r1$cph.enter)
summary(fits$r1$cph.recovery)
summary(fits$r1$cph.return)
```



### coxph shelves (tbd)



### coxph masses at recovery (tbd)






======


# # R2 

## = 2025-07-16 cohort B fups
- going to rerun analyses from cohort A just focusing on cohort B data

TODO

- [ ] R2 surv props
- [ ] are there diffs in the kms?
- [ ] compare R2 vs R1
  - [ ] shelf effects?
- [ ] 33 const cohort B are all getting filtered out for some reason...


```{r}
dfs <- list()
survObjs <- list()
fits <- list()
```
  
```{r}
dfs <- list_assign(dfs, r1 = list())
survObjs <- list_assign(survObjs, r1 = list())
fits <- list_assign(fits, r1 = list())
```

```{r}
# moved this up
# # actual conversion to decimal hours of km data
# km <- list_assign(km, data =  ogkm$data %>%
#                     mutate(across(starts_with(c("exit.", "dh.", "max", "day.")), ~ . * 24)))
# 
# km <- list_assign(km, subsets = list(ctrls = filter(km$data, trt.enter == trt.recover),
#                                      expts = filter(km$data, trt.enter != trt.recover),
#                                      only40 = filter(km$data, trt.enter == 40),
#                                      recs = filter(km$data, trt > 40),
#                                      rec24 = filter(km$data, trt == 40 | trt.duration == 24),
#                                      rec48 = filter(km$data, trt == 40 | trt.duration == 48)))

dfs$r1 <- list_assign(dfs$r1, 
                      allB = km$data %>% filter(cohort == "B"),
                      hotB = km$data %>% filter(is.40C == "Y"),
                      recB = km$data %>% filter(cohort == "B" & trt.duration > 0))
```

### coxph trt durations

```{r}
### use round 2 data
survObjs$r1 <- list_assign(survObjs$r1,
                            fromEnter = Surv(dfs$r1$recB$exit.fromenter, dfs$r1$recB$km.status),
                            fromRecovery = Surv(dfs$r1$recB$exit.fromrecover, dfs$r1$recB$km.status),
                            fromReturn = Surv(dfs$r1$recB$exit.fromreturn, dfs$r1$recB$km.status)
                            )

fits$r1 <- list_assign(fits$r1,
                    cph.enter = coxph(survObjs$r1$fromEnter ~ trt.recover * as.factor(trt.duration), 
                                      data = dfs$r1$recB),
                    cph.recovery = coxph(survObjs$r1$fromRecovery ~ trt.recover * as.factor(trt.duration), 
                                         data = dfs$r1$recB),
                    cph.return = coxph(survObjs$r1$fromReturn ~ trt.recover * as.factor(trt.duration),
                                       data = dfs$r1$recB)
                    )

                                       
summary(fits$r1$cph.enter)
summary(fits$r1$cph.recovery)
summary(fits$r1$cph.return)

# yay !!!
```

### coxph shelves

```{r}
fits$r1 <- list_assign(fits$r1, shelves = list())

fits$r1$shelves <- list_assign(fits$r1$shelves,
                               enterAdd = coxph(survObjs$r1$fromEnter ~ 
                                                  trt.recover * as.factor(trt.duration) + shelf,
                                                data = dfs$r1$recB),
                               enterInt = coxph(survObjs$r1$fromEnter ~ 
                                                  trt.recover * as.factor(trt.duration) * shelf,
                                                data = dfs$r1$recB),
                               recoverAdd = coxph(survObjs$r1$fromRecovery ~ 
                                                  trt.recover * as.factor(trt.duration) + shelf,
                                                data = dfs$r1$recB),
                               recoverInt = coxph(survObjs$r1$fromRecovery ~ 
                                                  trt.recover * as.factor(trt.duration) * shelf,
                                                data = dfs$r1$recB),
                               returnAdd = coxph(survObjs$r1$fromReturn ~ 
                                                  trt.recover * as.factor(trt.duration) + shelf,
                                                data = dfs$r1$recB),
                               returnInt = coxph(survObjs$r1$fromReturn ~ 
                                                  trt.recover * as.factor(trt.duration) * shelf,
                                                data = dfs$r1$recB))


summary(fits$r1$shelves$enterAdd)
summary(fits$r1$shelves$enterInt)
summary(fits$r1$shelves$recoverAdd)
summary(fits$r1$shelves$recoverInt)
summary(fits$r1$shelves$returnAdd)
summary(fits$r1$shelves$returnInt)

# ehh..
```


# # R1 archive

R1 is handled too differently so its analysis stuff gets moved here

## - df prep

```{r}
# set up empty lists and dfs
survObj <- list()
fits <- list()
testing <- list()

km <- ogkm
```

## - 2025-06-27 redoing cox fits lmao (**)

cuz i love a fresh start!!!

- goals
  - [x] set up km
    - [/] which is the best time frame to use?
  - [x] try a few cphs
  
### create fits

```{r}
survObj <- list_assign(survObj,
                       fromEnter = Surv(km$subsets$expts$exit.fromenter, km$subsets$expts$km.status),
                       fromRecovery = Surv(km$subsets$expts$exit.fromrecover, km$subsets$expts$km.status),
                       fromReturn = Surv(km$subsets$expts$exit.fromreturn, km$subsets$expts$km.status)
                       )
```

### coxphing (trt + shelves)

```{r}
fits <- list_assign(fits, 
                    cph.enter = coxph(survObj$fromEnter ~ trt.recover * as.factor(trt.duration), data = km$subsets$expts),
                    cph.recovery = coxph(survObj$fromRecovery ~ trt.recover * as.factor(trt.duration), data = km$subsets$expts),
                    cph.return = coxph(survObj$fromReturn ~ trt.recover * as.factor(trt.duration), data = km$subsets$expts),
                    )

summary(fits$cph.enter)
summary(fits$cph.recovery)
summary(fits$cph.return)
```

tldr trt doesnt matter except except for longest time frame

```{r}
obj <- Surv(km$subsets$only40$exit.fromenter, km$subsets$only40$km.status)
obj2 <- Surv(km$subsets$only40$exit.fromreturn, km$subsets$only40$km.status)
fits <- list_assign(fits, 
                    cph.enter.addshelf = coxph(obj ~ trt.recover * as.factor(trt.duration) + shelf, data = km$subsets$only40),
                    cph.enter.intshelf = coxph(obj ~ trt.recover * as.factor(trt.duration) * shelf, data = km$subsets$only40),
                    cph.return.addshelf = coxph(obj2 ~ trt.recover * as.factor(trt.duration) + shelf, data = km$subsets$only40),
                    cph.return.intshelf = coxph(obj2 ~ trt.recover * as.factor(trt.duration) * shelf, data = km$subsets$only40),)

summary(fits$cph.enter.addshelf)
summary(fits$cph.enter.intshelf)
summary(fits$cph.return.addshelf)
summary(fits$cph.return.intshelf)
```
tldr shelf effect outweighs trt effect...



## = 2025-06-22 coxph attempts

- todo
  - [x] shelf effects: look at starting exit-fromenter...

- notes:
  - also worked on: 2025-06-23, 2025-06-24
  - 2025-06-27: 
    - lowkey the fits arent that correct bc 1) the exit dates are calced wrong and 2) the `dh.<stage>` stuff was sorta assigned wrong (i think)
    - also i calced recovery time wrong lmao (used return time...)
  


```{r}
survObj <- list_assign(survObj, 
                       fromHatch = Surv(km$subsets$expts$exit.fromhatch, km$subsets$expts$km.status),
                       fromEnter = Surv(km$subsets$expts$exit.fromenter, km$subsets$expts$km.status),
                       fromRecovery = Surv(km$subsets$expts$exit.fromrecover, km$subsets$expts$km.status),
                       fromReturn = Surv(km$subsets$expts$exit.fromreturn, km$subsets$expts$km.status)
                       )
```


### survdiffing (**)

- NOTE this is where `kmdf` is

```{r trying survdiff interactions, eval=FALSE}

## so google ai results summary says that survdiff is not intended to work w interaction terms LOL... sure!

##### trying to figure out how to get the interaction to show up but idky something about it breaks the formula
  # renaming to nicer vars doesnt work...

#survdiff(survObj$fromHatch ~ km$subsets$expts$trt.duration + km$subsets$expts$trt.recover)
# trying to pick out the columns names to get the interaction to work. see other attempts below
           # pluck(km$subsets, expts, trt.recover):pluck(km$subsets, expts, trt.duration))
           # 
           # hoist(as.data.frame(km$subsets), "trt.recover"):hoist(as.data.frame(km$subsets), "trt.duration"))
           # 
           # km$subsets$[expts][km$subsets$expts$,]:km$subsets[expts][km$subsets$expts$trt.recover,])


#### other attempts 

# kmdf <- km$subsets$expts %>%
#   rename(duration = trt.duration,
#          recover = trt.recover,
#          fromrec = exit.fromrecover,
#          stat = km.status)
# make a subset so naming is nicer, apparently u shouldnt use $ in formulas
# 
# survdiff(Surv(fromrec, stat) ~ 
#           duration + recover + interaction(duration, recover), data = kmdf) 
# this is bad (dont use interaction() cuz its ‚â† to using :)
# 
# survdiff(Surv(fromrec, stat) ~ 
#           duration + recover + duration:recover, data = kmdf) # doesnt work
# 
#survdiff(formula = Surv(kmdf$fromrec, kmdf$stat) ~ duration + recover + duration:recover, data = kmdf) # doesnt work


### 3

# survdiff(survObj$fromHatch ~ poly(c(km$subsets$expts$trt.duration, km$subsets$expts$trt.recover), n = 2)) 
  # im totally using poly() wrong here but idr how to use it. but also def not what im looking for

### 4 am i going nuts

# anova(lm(fromrec ~ duration*recover, data = kmdf)) # i am not...

```


```{r eval=FALSE}
# survdiff starting from hatch time
## recovery temp + duration
survdiff(survObj$fromHatch ~ km$subsets$expts$trt.duration + km$subsets$expts$trt.recover 
         #+ `km$subsets$expts$trt.recover`:`km$subsets$expts$trt.duration`
         )

#######

# survdiff starting from enter time
survdiff(survObj$fromEnter ~ km$subsets$expts$trt.duration + km$subsets$expts$trt.recover) ## recovery temp + duration


#######

# looking for diffs starting at recovery
survdiff(survObj$fromRecovery ~ km$subsets$expts$trt.recover) ## based on recovery temp


survdiff(survObj$fromRecovery ~ km$subsets$expts$trt.duration) ## based on recovery period


survdiff(survObj$fromRecovery ~ km$subsets$expts$trt.duration + km$subsets$expts$trt.recover) ## temp + duration (cant do the interaction)


########

# survdiff starting from returning time
survdiff(survObj$fromReturn ~ km$subsets$expts$trt.duration + km$subsets$expts$trt.recover) ## recovery temp + duration

```
### cphing

#### fitting cph

##### effects of recovery temp and duration
```{r}
fits <- list_assign(fits, cph.enter = coxph(survObj$fromEnter ~ trt.recover * as.factor(trt.duration), 
                                               data = km$subsets$expts))
summary(fits$cph.enter)


fits <- list_assign(fits, cph.recovery = coxph(survObj$fromRecovery ~ trt.recover * as.factor(trt.duration), 
                                               data = km$subsets$expts))
summary(fits$cph.recovery)


fits <- list_assign(fits, cph.return = coxph(survObj$fromReturn ~ trt.recover * as.factor(trt.duration), 
                                             data = km$subsets$expts))
summary(fits$cph.return)


fits <- list_assign(fits, cph.return2 = coxph(survObj$fromReturn ~ trt.recover * trt.duration, 
                                             data = km$subsets$expts))
summary(fits$cph.return2)
# same results as above

fits <- list_assign(fits, cph.return3 = coxph(survObj$fromReturn ~ as.factor(trt.recover) * trt.duration, 
                                             data = km$subsets$expts))
summary(fits$cph.return3)

```

so the cph fits only really matter starting from the enter time?

##### shelf effects

```{r}
# looking at shelf effects

fits <- list_assign(fits, cph.shelf = coxph(survObj$fromEnter ~ trt.recover * as.factor(trt.duration) * shelf, 
                                               data = km$subsets$expts))
summary(fits$cph.shelf)


fits <- list_assign(fits, cph.shelf2 = coxph(survObj$fromEnter ~ shelf + trt.recover * as.factor(trt.duration), 
                                               data = km$subsets$expts))
summary(fits$cph.shelf2)

fits <- list_assign(fits, cph.shelf3 = coxph(survObj$fromEnter ~ shelf + trt.recover * trt.duration, 
                                               data = km$subsets$expts))
summary(fits$cph.shelf3)
```

tldr in all cases, `trt.recover` becomes signif once u throw in the shelf LOL.. (generally p < 0.5)

#### plotting cph

```{r eval=FALSE}
# plot cphs...
# plot(x = fits$cph.recovery$linear.predictors,
#      y = fits$cph.recovery$residuals,
#      data = km$subsets$expts, 
#      #facet.by = trt.recovery
#      )
  # this is not how to use survival::plot.coxph lolol (cph doesnt give u a survival curve per se. its a regression)

autoplot(survfit(coxph(survObj$fromReturn ~ trt.recover * trt.duration, 
                                             data = km$subsets$expts)),
         facets = TRUE,
         )
```

```{r eval=FALSE}
# per google:
# check if prop hazards assumption is met (is HR betwn groups constant over time?)
  # https://stats.stackexchange.com/questions/560975/how-to-interpret-schoenfield-residual-plot
ggcoxzph(cox.zph(fits$cph.enter), ggtheme = theme_minimal())
ggcoxzph(cox.zph(fits$cph.recovery), ggtheme = theme_minimal())
ggcoxzph(cox.zph(fits$cph.return), ggtheme = theme_minimal())

# TODO idk what im doing here so... lets revisit later
```

```{r}
fit <- survfit(Surv(kmdf$exit.fromenter, kmdf$stat) ~ recover + duration, data = kmdf) 
# ok survfit super doesnt like "subsets" being in the df name lol

# kmdf_summ <- kmdf %>%
#   group_by(trt)
#   summarise()

ggsurvplot(fit, 
           data = kmdf,
           conf.int = TRUE,
           #xlim = c(45823, 45841),
           #facet.by = "trt.duration",
           facet.by = "duration",
           #linetype = "strata",
           palette = "strata") +
  
  # i think the stuff for vline needs to come from a separate df LOL...
  # also, lowkey not sure how this works considering the time depends on the hatch day... (avg them??)
  
  geom_vline(xintercept = kmdf$dh.recover - kmdf$dh.exit, #tried w dh.enter, kinda wonky
             #color = "red"
             #aes(xintercept = kmdf$dh.recover - kmdf$dh.enter, color = kmdf$recover)
             ) +
  geom_vline(xintercept = kmdf$return - kmdf$df.exit,
             color = "blue")

# TODO idk gotta think about wtf im plotting for this one a bit... draw it out
  
```


---
title: "wrangle-tdt"
date: "2025-06-16"
---

# 0. preamble

wrangling 2025 tdt data

final code is purled to a `.R` script, manually rerun `purl()` as needed to update the wrangling script for analyses.

(only need to run the `.Rmd` if troubleshooting, otherwise just run the `_p.R` from the corresponding wrangle scripts)

```{r wrangle setup and purling, eval=FALSE, include=FALSE, purl=FALSE}
# run manually when new wrangle script is needed (will overwrite the existing .R)

# purls the current .Rmd file
knitr::purl("wrangle.Rmd", "wrangle_p.R")

# creates an archive of the current .Rmd file
here::i_am("2025/tdt/wrangle.Rmd")
library(here)
source(here::here("set-paths.R"))
knitr::purl("wrangle.Rmd", paste0(here(bin_paths$y25$tdt), 
                                      "/etc/wrangle-archive/", format(Sys.time(), "%y%m%d"), "_wrangle_p.R"))
```


# 1. loading

```{r about, echo=TRUE, eval = TRUE}
# tdt/wrangle.R

# knitted wrangling code for 2025 tdt data
# source() this in corresponding analysis scripts.
```

```{r load utils}
library(here)

source(here::here("set-paths.R"))

library(tidyverse)
# library(conflicted)
# conflicts_prefer(dplyr::filter)
```

```{r load data}
data <- read.csv(here(bin_paths$y25$tdtdata, "clean-working.csv"), header = TRUE)
```

# 2. df prep

## calc exit times; recode events

```{r calc exit times}
# find max dh.exit for expt bugs, use this # as the basis for the others (add +1 to it?)
max <- data %>%
  filter(trt.enter ==  40) %>%
  group_by(cohort) %>%
  summarise(max = max(dh.exit, na.rm = TRUE))

# recode times for ctrls... (tho they will be dropped later lol)
  # things that die before recovery/returning should be NA!!!!!
data <- data %>%
  merge(., max) %>%
  mutate(dh.exit = case_when(is.na(dh.exit) ~ max + 1, 
                             # only do max+1 bc round B ctrls were culled after +1 day
                             TRUE ~ dh.exit), 
         
         ## standardise event times by trt enter date 
         ## (bc doesnt super make sense to start at hatch date..)
         day.enter = dh.enter - dh.enter,
         day.recover = dh.recover - dh.enter,
         day.return = dh.return - dh.enter,
         day.exit = dh.exit - dh.enter) %>%
  
  ## remove hot bugs that do not have fates (i.e. got lost or sth/in progress)
  filter(!(trt >= 40 & is.na(fate)))

```

```{r generate filtering binaries}
# add some binaries; recalc other times
data <- data %>% mutate(
  # exit times, except this doesnt make sense lol... recalc w tt.times?
  # exit.fromhatch = dh.exit - dh.hatch, # needed for some cohort A stats if u want to bother fixing this
  # exit.fromenter = dh.exit - dh.enter,
  # exit.fromrecover = dh.exit - dh.recover,
  # exit.fromreturn = dh.exit - dh.return,
  
  # calc exit times using days standardised by expt enter date
  # (i.e. d0 = expt enter date)
  exit.fromenter = day.exit - day.enter,
  exit.fromrecover = day.exit - day.recover,
  exit.fromreturn = day.exit - day.return,
  
  # some filtering binaries and labels
  is.40C = case_when(trt.enter == 40 ~ "Y",
                     TRUE ~ "N"),
  is.ctrl = case_when(trt < 100 ~ "Y",
                      TRUE ~ "N"),
  trt.recover = case_when(is.na(trt.recover) ~ trt.enter,
                          TRUE ~ trt.recover),
  trt.lab = formatC(trt, width = 3, flag = "0"))

# redo km statuses to be consistent with how the package expects it to be coded
  # 1 = death, 0 = censored
data <- data %>% mutate(km.status = case_when(dh.exit > max ~ 0,
                                              TRUE ~ 1)) %>%
  select(-max)
```

## create subsets

```{r}
# create new list
dfs <- list()
```
### cohort A
```{r cohort A only}
dfs <- list_assign(dfs, dataA = filter(data, cohort == "A"))

kmA <- list(data = dfs$dataA,
            ctrls = filter(dfs$dataA, trt.enter == trt.recover),
            expts = filter(dfs$dataA, trt.enter != trt.recover),
            only40 = filter(dfs$dataA, trt.enter == 40),
            recs = filter(dfs$dataA, trt > 40),
            rec24 = filter(dfs$dataA, trt == 40 | trt.duration == 24),
            rec48 = filter(dfs$dataA, trt == 40 | trt.duration == 48))

```

### cohort B onwards
```{r ctrls vs exptal subsets}
# prep: filter out exptals from cohort A and convert dh.times to hours
dfs <- list_assign(dfs, data = filter(data, !(cohort == "A" & trt > 100)))
dfs$data <- mutate(dfs$data, across(starts_with(c("exit.", "dh.", "day.")), ~ . * 24))

# ## TODO:BUG some cohort C individs are breaking with negative exit times (keep this until fixed)
# 2025-08-21 i think its fixed...
# dfs$data <- dfs$data %>%
#   mutate(exit.fromenter = case_when(exit.fromenter < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromenter)),
#          exit.fromrecover = case_when(exit.fromrecover < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromrecover)),
#          exit.fromreturn = case_when(exit.fromreturn < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromreturn)))

# extract subsets
  # (hopefully should allow for retaining most of the original names bc im too lazy to change them...)
dfs <- list_assign(dfs, subsets = list(ctrls = filter(dfs$data, trt.enter == trt.recover),
                                       expts = filter(dfs$data, trt.enter != trt.recover),
                                       at40 = filter(dfs$data, trt.enter == 40),
                                       recs = filter(dfs$data, trt > 40),
                                       rec24 = filter(dfs$data, trt == 40 | trt.duration == 24),
                                       rec48 = filter(dfs$data, trt == 40 | trt.duration == 48)))
```

```{r 40 bugs subsets}
# create 40C recovery time subsets
  
  # then make versions of just 24/48h recovery (and modify the 40C group accordingly,
  # i.e. add 24/48h to the times)
dfs <- list_assign(dfs, subsets40 = list(all = dfs$subsets$at40))

## assign return/recovery stuff to 40C ctrls; treat differences in time as "0"
dfs$subsets40$all[dfs$subsets40$all$trt == 40,] <- 
  dfs$subsets40$all[dfs$subsets40$all$trt == 40,] %>% 
  mutate(dh.recover = dh.enter + 24,
         dh.return = dh.recover,
         exit.fromrecover = dh.exit - dh.recover,
         exit.fromreturn = dh.exit - dh.return)

## make 24/48h-only versions and modify "return" times accordingly
dfs$subsets40 <- list_assign(dfs$subsets40, 
                             rec24 = filter(dfs$subsets40$all, trt %in% c(40, 119, 126, 133)),
                             rec48 = filter(dfs$subsets40$all, trt %in% c(40, 219, 226, 233)))

dfs$subsets40$rec24[dfs$subsets40$rec24$trt == 40,] <- 
  dfs$subsets40$rec24[dfs$subsets40$rec24$trt == 40,] %>%
  mutate(trt.duration = 24,
         across(c(dh.return, exit.fromreturn), ~ . + 24))

dfs$subsets40$rec48[dfs$subsets40$rec48$trt == 40,] <- 
  dfs$subsets40$rec48[dfs$subsets40$rec48$trt == 40,] %>%
  mutate(trt.duration = 48,
         across(c(dh.return, exit.fromreturn), ~ . + 48))
```


# 3. cleanup

```{r cleanup}
dfs <- list_modify(dfs, dataA = zap())

bin_wrangled <- list(data = data,
                     km = dfs,
                     kmA = kmA)

rm(max,
   data, dfs, kmA)
```



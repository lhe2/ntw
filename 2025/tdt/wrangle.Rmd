---
title: "wrangle-tdt"
date: "2025-06-16"
---

# 0. preamble

wrangling 2025 tdt data

final code is purled to a `.R` script, manually rerun `purl()` as needed to update the wrangling script for analyses.

(only need to run the `.Rmd` if troubleshooting, otherwise just run the `_p.R` from the corresponding wrangle scripts)

```{r wrangle setup and purling, eval=FALSE, include=FALSE, purl=FALSE}
# run manually when new wrangle script is needed (will overwrite the existing .R)

# purls the current .Rmd file
knitr::purl("wrangle.Rmd", "wrangle_p.R")

# creates an archive of the current .Rmd file
here::i_am("2025/tdt/wrangle.Rmd")
library(here)
source(here::here("set-paths.R"))
knitr::purl("wrangle.Rmd", paste0(here(bin_paths$y25$tdt), 
                                      "/wrangle-archive/", format(Sys.time(), "%y%m%d"), "_wrangle_p.R"))
```


# 1. loading

```{r about, echo=TRUE, eval = TRUE}
# tdt/wrangle.R

# knitted wrangling code for 2025 tdt data
# source() this in corresponding analysis scripts.
```

```{r load utils}
library(here)

source(here::here("set-paths.R"))

library(tidyverse)
# library(conflicted)
# conflicts_prefer(dplyr::filter)
```

```{r load data}
data <- read.csv(here(bin_paths$y25$tdtdata, "clean-working.csv"), header = TRUE)
```

# 2. df prep

## calc exit times; recode events

```{r calc exit times}
# find max dh.exit for expt bugs, use this # as the basis for the others (add +1 to it?)
max <- data %>%
  filter(trt.enter ==  40) %>%
  group_by(cohort) %>%
  summarise(max = max(dh.exit, na.rm = TRUE))

# recode times for ctrls... (tho they will be dropped later lol)
  # things that die before recovery/returning should be NA!!!!!
data <- data %>%
  merge(., max) %>%
  mutate(dh.exit = case_when(is.na(dh.exit) ~ max + 1, 
                             # only do max+1 bc round B ctrls were culled after +1 day
                             TRUE ~ dh.exit), 
         
         ## standardise event times by trt enter date 
         ## (bc doesnt super make sense to start at hatch date..)
         day.enter = dh.enter - dh.enter,
         day.recover = dh.recover - dh.enter,
         day.return = dh.return - dh.enter,
         day.exit = dh.exit - dh.enter) %>%
  
  ## remove hot bugs that do not have fates (i.e. got lost or sth/in progress)
  filter(!(trt >= 40 & is.na(fate)))

```

```{r generate filtering binaries}
# add some binaries; recalc other times
data <- data %>% mutate(
  # exit times, except this doesnt make sense lol... recalc w tt.times?
  # exit.fromhatch = dh.exit - dh.hatch, # needed for some cohort A stats if u want to bother fixing this
  # exit.fromenter = dh.exit - dh.enter,
  # exit.fromrecover = dh.exit - dh.recover,
  # exit.fromreturn = dh.exit - dh.return,
  
  # calc exit times using days standardised by expt enter date
  # (i.e. d0 = expt enter date)
  exit.fromenter = day.exit - day.enter,
  exit.fromrecover = day.exit - day.recover,
  exit.fromreturn = day.exit - day.return,
  
  # some filtering binaries and labels
  is.40C = case_when(trt.enter == 40 ~ "Y",
                     TRUE ~ "N"),
  is.ctrl = case_when(trt < 100 ~ "Y",
                      TRUE ~ "N"),
  trt.recover = case_when(is.na(trt.recover) ~ trt.enter,
                          TRUE ~ trt.recover),
  trt.lab = formatC(trt, width = 3, flag = "0")
)
# mutate(starts_with("exit") ~ case_when(. < 0, ~ NA_real_)) ## WIP
                  


# redo km statuses to be consistent with how the package expects it to be coded
  # 1 = death, 0 = censored
data <- data %>% mutate(km.status = case_when(dh.exit > max ~ 0,
                                              TRUE ~ 1)) %>%
  select(-max)
```

## create subsets

```{r}
# create new list
dfs <- list()
```

```{r cohort A}
dfs <- list_assign(dfs, dataA = filter(data, cohort == "A"))

kmA <- list(data = dfs$dataA,
            ctrls = filter(dfs$dataA, trt.enter == trt.recover),
            expts = filter(dfs$dataA, trt.enter != trt.recover),
            only40 = filter(dfs$dataA, trt.enter == 40),
            recs = filter(dfs$dataA, trt > 40),
            rec24 = filter(dfs$dataA, trt == 40 | trt.duration == 24),
            rec48 = filter(dfs$dataA, trt == 40 | trt.duration == 48))

```

```{r cohort B onwards}
# prep: filter out exptals from cohort A and convert times to hours
dfs <- list_assign(dfs, data = filter(data, !(cohort == "A" & trt > 100))) # keep the ctrls from A only

dfs$data <- mutate(dfs$data, across(starts_with(c("exit.", "dh.", "max", "day.")), ~ . * 24))

## TODO:BUG some cohort C individs are breaking with negative exit times (keep this until fixed)
dfs$data <- dfs$data %>%
  mutate(exit.fromenter = case_when(exit.fromenter < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromenter)),
         exit.fromrecover = case_when(exit.fromrecover < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromrecover)),
         exit.fromreturn = case_when(exit.fromreturn < 0 ~ NA_real_, TRUE ~ as.numeric(exit.fromreturn)))

# extract subsets
  # (hopefully should allow for retaining most of the original names bc im too lazy to change them...)
dfs <- list_assign(dfs, subsets = list(ctrls = filter(dfs$data, trt.enter == trt.recover),
                                       expts = filter(dfs$data, trt.enter != trt.recover),
                                       at40 = filter(dfs$data, trt.enter == 40),
                                       recs = filter(dfs$data, trt > 40),
                                       rec24 = filter(dfs$data, trt == 40 | trt.duration == 24),
                                       rec48 = filter(dfs$data, trt == 40 | trt.duration == 48)))

# extract 40C recovery time subsets
dfs <- list_assign(dfs, subsets40 = list(rec24 = filter(dfs$subsets$at40, trt %in% c(40, 119, 126, 133)),
                                       rec48 = filter(dfs$subsets$at40, trt %in% c(40, 219, 226, 233))))

dfs$subsets40$rec24[,"trt.duration"] <- 24
dfs$subsets40$rec48[,"trt.duration"] <- 48
```


# 3. cleanup

```{r cleanup}
dfs <- list_modify(dfs, dataA = zap())

bin_wrangled <- list(data = data,
                     km = dfs,
                     kmA = kmA)

rm(max,
   data, dfs, kmA)
```

# archived code 

(just for ref, not included in the purl)

```{r df prep for in progress data, eval=FALSE, include=FALSE, purl=FALSE}
## originally for doing analysis while bugs were in progress...
## TODO figure out what to do w this... need to wrangle the data a bit tho (see below section)

# for now, censor if they get to 4th
data <- data %>%
  mutate(fate = case_when(!is.na(jdate.4th) ~ 1,
                          TRUE ~ as.numeric(fate)))

# for bugs in progress, arbitrarily add today as a censor...?
data <- data %>%
  mutate(now = as.numeric(as.Date(today(), format = "%j")),
         dv.exit = case_when(is.na(jdate.exit) ~ now + 25580,
                                TRUE ~ dv.exit),
         fate = case_when(dv.exit == now ~ 1,
                          TRUE ~ fate))

# change duration to when entered (aka subtr out the buffer)
```

```{r recode exit times, eval=FALSE, purl=FALSE, include = FALSE} 
## OLD -- this works for when there is only 1 cohort LOL

# recode exit times

# find max dh.exit for expt bugs, use this # as the basis for the others (add +1 to it?)
max <- data %>%
  filter(trt > 100) %>%
  summarise(max(dh.exit)) %>%
  pull()


# create new list
km <- list()

# recode times for ctrls... (tho they will be dropped later lol)
  # things that die before recovery/returning should be NA!!!!!
km <- list_assign(km, data = data %>%
                    mutate(dh.exit = case_when(is.na(dh.exit) ~ max + 2, 
                                               TRUE ~ dh.exit),
                           
                           ## ctrls should not have a recover/return time lol
                           # dh.recover = case_when(trt < 100 & is.na(dh.recover) ~ dh.enter,
                           #                        TRUE ~ dh.recover),
                           # dh.return = case_when(trt < 100 & is.na(dh.return) ~ dh.enter,
                           #                       TRUE ~ dh.return),
                           
                           ## standardise exit times by trt enter date (enter date = d0)
                           # doesnt super make sense to start at hatch date..
                           tt.enter = dh.enter - dh.enter,
                           tt.recover = dh.recover - dh.enter,
                           tt.return = dh.return - dh.enter,
                           tt.exit = dh.exit - dh.enter,
                    )
                  )
  
```

```{r df prep for km fits, eval=FALSE, include=FALSE, purl=FALSE}

### TODO wonky bc it uses the old julian dates, but holding onto this cuz just in case but otherwise rewritten above

# also JK for km curves, 1 = death and 0 = censored
# and adding other exit info...
km.data <- data %>% 
  #drop_na(fate) %>%
  mutate(km.status = case_when(!is.na(jdate.4th) ~ 0,
                          !is.na(jdate.exit) ~ 1),
         # not sure how to incorporate the dv stuff for 4ths...
         km.exit = case_when(!is.na(jdate.4th) ~ jdate.4th + 25580,
                             !is.na(dv.exit) ~ dv.exit),
         instar.exit = case_when(!is.na(jdate.4th) ~ 4,
                                 TRUE ~ as.numeric(instar.exit)),
         is.40 = case_when(trt.enter == 40 ~ "Y",
                          TRUE ~ "N"),
         is.ctrl = case_when(trt < 100 ~ "Y",
                             TRUE ~ "N"),
         trt.recover = case_when(is.ctrl == "Y" ~ trt.enter,
                                 TRUE ~ trt.recover))
```




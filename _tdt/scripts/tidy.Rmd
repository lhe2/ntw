---
title: "tidy tdt"
date: "2026-01-06"
---

# preamble

get 2025 data into tidy format.

final code is purled to a `.R` script, rerun `purl` step as needed to update the wrangling for analyses

- roadmap
  - purling stuff
  - import data, libs
  - make new columns, binaries, etc
  - cleanup
  
```{r for purling, eval=FALSE, include=FALSE, purl=FALSE}
here::i_am("_tdt/scripts/tidy.Rmd") # set wd

knitr::purl(here::here("_tdt/scripts/tidy.Rmd"), here::here("_tdt/scripts/R/tidy.R")) # purl current script
  # save and apply updates to current .Rmd before purling!
```

# # load libs & pkgs

```{r about}
# tidy tdt.R

# knitted tidying code for tdt data
# source() this in corresponding analysis scripts.
```

```{r load libs}
library(tidyverse)
library(data.table) #rbindlist
library(here)
```

```{r loading}
# drop bugs with unknown fates
df_import <- read.csv(here("_tdt/data/clean/dev.csv"), header = TRUE) %>%
  filter(!is.na(fate))
```


# # futzing

roadmap:

1) create simulated 40 ctrls for 24h and 48h recovery (bc lacking them)
  - also adjust jdates accordingly

2) corrections and other calcs
more date corrections
  - just standardise the cutoff for bugs that survived (fate = 1): (+1 the last day of the expt bugs, bc of round B cutoff, assuming that they lived past that)
  - stdise all event times by enter date (so day 0 = when entered)
  
more calcs
  - calc time to exit with t0 from enter, recover, return

## simulate 40 ctrls

```{r}
df_all <- list(
    df_import,
    df_import %>% 
      filter(trt == 40) %>% 
      mutate(trt.duration = 24,
             dh.recover = case_when(dh.exit > dh.enter + 24 ~ dh.enter + 24),
             dh.return = case_when(dh.exit > dh.recover + 24 ~ dh.recover + 24),
             jdate.recover = case_when(!is.na(dh.recover) ~ jdate.enter + 1),
             jdate.return = case_when(!is.na(dh.return) ~ jdate.enter + 2)),
    df_import %>%
      filter(trt == 40) %>% 
      mutate(trt.duration = 48,
             dh.recover = case_when(dh.exit > dh.enter + 24 ~ dh.enter + 24),
             dh.return = case_when(dh.exit > dh.recover + 48 ~ dh.recover + 48),
             jdate.recover = case_when(!is.na(dh.recover) ~ jdate.enter + 1),
             jdate.return = case_when(!is.na(dh.return) ~ jdate.enter + 3))
  ) %>%
  rbindlist()
  
```

## recalc exit times

```{r}
dfs_tidy <- list(
  wide = df_all %>%
    # select(c("trt.enter", "cohort", "id", "fate", "trt.duration",
    #          ends_with(c("hatch", "enter", "recover", "return", "exit", "died", "culled")))) %>%
    
    ## assign cutoff 
    merge(., 
          df_import %>%
            filter(trt.enter ==  40) %>%
            group_by(cohort) %>%
            summarise(max = max(dh.exit, na.rm = TRUE))) %>%
    mutate(dh.max = case_when(fate == "culled" ~ max + 1,
                              TRUE ~ dh.exit)) %>% 
    
    ## stdise times so t0 = enter
    mutate(dt.enter = dh.enter - dh.enter,
           dt.recover = dh.recover - dh.enter,
           dt.return = dh.return - dh.enter,
           dt.exit = dh.max - dh.enter) %>% 

    ## recode km status with how package expects it
    ## 1 = death, 0 = alive/censored (culled after endpt), 
    ## 2 = death for other reasons (pmcs)
    mutate(status = case_when(fate == "pmc" ~ 2,
                              fate %in% c("died", "pmd") ~ 1,
                              fate == "culled" ~ 0)
           ) %>%
    select(-max)
)

# dfs_tidy$wide %>%
#   filter(!is.na(dh.died) & status == 0,) %>%
#   View()
```

```{r}
## calc expt exit times from rec/return/exit (for surv stats/viz) -- see xlxs
dfs_tidy <- list_modify(
  dfs_tidy,
  long =
    dfs_tidy$wide %>%
    mutate(tt.exit.fromenter = dt.exit - dt.enter,
           tt.exit.fromrecover = dt.exit - dt.recover,
           tt.exit.fromreturn = dt.exit - dt.return) %>%
    pivot_longer(starts_with("tt.exit"),
                 names_to = c(".value", "subset"),
                 names_pattern = "(tt\\.exit)\\.([a-z]*)"
                 ) %>% 
    drop_na(tt.exit)
)
```

# # export

## cleanup
```{r cleanup}
rm(df_import, df_all)
```
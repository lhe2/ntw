---
title: "import 2025 tdt data"
date: "2026-01-07"
---

# preamble


## roadmap

-   loading
-   filtering and fixes
    -   filter out bad bugs
    -   fix timepoints (for consistency)
    -   fix weights
    - fix parsing of culled vs died
    - fix instar exits
-   standardising
    -   times
        -   calculate dh cols
        -   recalculate exits for ctrls/culled
        -   convert julian dates
    -   binaries?
        -   determine fates (for KM?)

# loading

## - packages

```{r loading message = FALSE}
library(tidyverse)
library(lubridate) # for as_datetime
library(googlesheets4)

here::i_am("_tdt/scripts/import.Rmd")
library(here)
```

## - data

```{r import}
# import corrections:
  # prefix "2025" to dates
  # replace commas in notes
  # remove "dv." col bc not correctly calculated in gsheets...
df_raw <-
  read_sheet("https://docs.google.com/spreadsheets/d/1rxZSI-8ubhMkeM2Sh1xNi5IKF0Vt_BDFItAg_Ak476M/edit?gid=1826657546#gid=1826657546",
             sheet = "tdt jun 2025", col_types = "c", na = c("#VALUE!")) %>%
  drop_na() %>% na_if("--") %>% na_if("") %>%
  mutate(across(starts_with("date."), ~ str_c("2025/", .)),
         across(notes, gsub, pattern = ",", replacement = ";")) %>%
  rename(trt = treatment) %>%
  select(-starts_with("dv"))
```

# filtering and fixes
    
## - fix values

filter bugs accidentally culled before 3rd (dont fix `instar.exit` before this)

weights: 
  - drop masses of bugs at molts/return to 40C if they were already dead by the am (weight will not be accurate)

standardise timepts (align everything to `hatch.time`):
  - R2 d2 pm expt bugs recover time (returned late)
  - R3 d2 expt bugs recover time (data entry typo?)
  - R3 d2 26C bugs enter time (entered late)
  
parse culled vs died better

fix `instar.exit`

fix `fate`? (based on their expected deaths at 40C trts and survival at other trts)
  - 0 = died
  - 1 = surved to 4th (if expt, which none did) or to 3rd (slow ctrls were culled at 3rd)
  - 2 = culled (i.e. died before 1 or 2; usually disease, for the most part)

```{r fixes}
df_filtered <- df_raw %>%
  ## drop bugs accidentally culled before 3rd
  filter(!(!is.na(date.culled) & instar.exit < 3)) %>%
  
  ## fix masses
  pivot_longer(c(ends_with(c("3rd", "4th", "return")), -starts_with(c("h", "time"))),
               names_to = c(".value", "event"), names_sep = "\\.") %>%
  mutate(mass = case_when(date == date.died & when.died == "am" ~ NA_real_,
                          TRUE ~ as.numeric(mass))) %>%
  pivot_wider(names_from = event, values_from = c("date", "mass"),
              names_glue = "{.value}.{event}") %>%
  
  ## align timepts
  mutate(time.return = case_when(date.hatch == "2025/7/7" & trt > 200 & 
                                   !is.na(date.return) ~ as.character(time.hatch),
                                 TRUE ~ as.character(time.return))) %>%
  mutate(time.recover = case_when(date.hatch == "2025/7/24" & trt > 100 &
                                    !is.na(date.return) ~ as.character(time.hatch),
                                  TRUE ~ as.character(time.recover))) %>%
  mutate(time.enter = case_when(date.hatch == "2025/7/25" & trt == 26 ~ "12:00",
                                TRUE ~ as.character(time.enter))) %>%
  
  ## better parsing of culled vs exit
  mutate(time.culled = case_when(date.culled == "2025/8/6" ~ "12:00",
                                 date.culled == "2025/6/24" ~ "13:07",
                                 !is.na(date.culled) ~ time.died),
         time.died = case_when(!is.na(time.culled) ~ NA_character_,
                               TRUE ~ time.died),
         when.died = case_when(!is.na(date.culled) ~ NA_character_,
                               TRUE ~ when.died)) %>%
  
  ## fix instar.exit (dont know if need, but the gsheets is wrong for older bugs lol)
  mutate(instar.exit = case_when(!is.na(date.pupa) ~ "pupa",
                                 !is.na(date.wander) ~ "wander",
                                 !is.na(date.6th) ~ "6",
                                 !is.na(date.5th) ~ "5",
                                 !is.na(date.4th) ~ "4",
                                 !is.na(date.3rd) ~ "3",
                                 !is.na(date.2nd) ~ "2",
                                 TRUE ~ "1")) %>%
  
  ## fix fates (based on bugs at 40 being expected to die)
  mutate(fate = case_when(!is.na(date.culled) & grepl("disease", notes) ~ 2,
                          !is.na(date.died) ~ 0,
                          !is.na(date.4th) | (!is.na(date.3rd) & trt.type == "ctrl") ~ 1)
         )

```

## - stdise cols & times

stdise col formats and calcs
  - trt stuff: dd.hatch/enter/recover/return/died/culled
  - fix gaps in recover/return/etc
  
add jdate (tho mostly we are interested in the `dd.` cols for analyses)

```{r datetime calcs}
df_cleaned <- df_filtered %>%
  ## create date-time objs to calc decimal days
  # arbitrarily assign "noon" if time is missing
  mutate(time.culled = case_when(!is.na(date.culled) & is.na(time.culled) ~ "12:00",
                                 TRUE ~ time.culled),
         dd.hatch = paste(date.hatch, time.hatch),
         dd.enter = paste(date.enter, time.enter),
         dd.recover = paste(date.recover, time.recover),
         dd.return = paste(date.return, time.return),
         dd.culled = paste(date.culled, time.culled),
         dd.died = paste(date.died, time.died)) %>%
  na_if("NA NA") %>% 
  mutate(dd.exit = case_when(!is.na(dd.died) ~ dd.died,
                             !is.na(dd.culled) ~ dd.culled,
                             TRUE ~ NA_character_)) %>% 
  
  ## add recovery/etc fixes for ctrls
  # (their dd.recover/return = the same as dd.enter)
  # TODO or do this later when wrangling?
  mutate(dd.recover = case_when(trt.duration == 0 ~ dd.enter,
                                TRUE ~ dd.recover),
         dd.return = case_when(trt.duration == 0 ~ dd.enter,
                               TRUE ~ dd.return)) %>%
  

  ## formatting
  # convert date-times (sec) to decimal days
  mutate(across(starts_with("date."), as.Date, "%Y/%m/%d"),
         across(starts_with("date."), as.Date, "%j"),
         across(starts_with("dd."), as_datetime, format = "%Y/%m/%d %H:%M"),
         across(starts_with("dd."), ~ as.numeric(.)/(60*60*24))) %>%
  rename_with(., ~paste0("j", .), starts_with("date.")) %>%
  mutate(across(c(trt, trt.enter, trt.recover, trt.duration,
                  id, instar.exit, fate, starts_with(c("mass", "jdate"))), as.numeric))
```

# export

```{r}
today <- format(Sys.time(), "%y%m%d-%H%M")

# export filtered df as raw per corrections
write.csv(df_filtered, file = paste0(here("_tdt/data/raw/"), "dev_", today, ".csv"), row.names = FALSE)

# extract useful stuff
export <- df_cleaned %>%
  select(c("cohort", "shelf", "id", starts_with(c("trt", "jdate", "mass", "dd.")), "fate"))
write.csv(export, file = paste0(here("_tdt/data/clean/dev.csv")))
```

```{r}
# clean up
rm(df_raw, df_filtered, df_cleaned, export, today)
```
